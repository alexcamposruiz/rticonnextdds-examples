
# Connext DDS

RTI Connext DDS is a software connectivity framework for real-time distributed
applications. It provides the middleware communications service that
programmers need to distribute time-critical data between embedded and/or
enterprise devices or nodes. Connext DDS uses a publish-subscribe
communications model to make data-distribution efficient and robust. Connext
DDS also supports the Request-Reply communication pattern.

In this directory you will find examples that illustrate some of the most
important features of the RTI Connext DDS core libraries. For documentation,
including the Getting Started Guide, User's Manual, Release Notes, and more see
https://community.rti.com/documentation.

## Examples

| Example | Description | C | C++ 98 | C++ 11 | Python | Java | C# |
| ------- | ----------- | - | ----- | ----- | ------ | ---- | -- |
| [asynchronous publication](asynchronous_publication) | **Asynchronous Publisher**: This example shows how to configure a *DataWriter* for asynchronous publication. This means that instead of sending a sample before returning from `write()`, the data is enqueued and sent according to a flow controller. There are three default flow controllers available. The first performs no throttling, and allows data to be send as soon as `write()` is called. The second, a fixed rate flow controller, allows data to be sent only once per second. The third allows manual control; that is, accumulated data is sent only on calls to `trigger_flow()`. All flow controllers allow messages to be coalesced into as few network packets as possible. [(...)](asynchronous_publication) | [c](asynchronous_publication/c) | [c++98](asynchronous_publication/c++98) | [c++11](asynchronous_publication/c++11) | [py](asynchronous_publication/py) | [java](asynchronous_publication/java) | [cs](asynchronous_publication/cs) |
| [asyncwaitset](asyncwaitset) | **Asynchronous WaitSet**: *The Asynchronous WaitSet (AsyncWaitSet)* is a specialization of the WaitSet that performs the wait asynchronously using *one or more separate threads of execution*. Additionally, the *AsyncWaitSet* dispatches the attached and active conditions upon wakeup. [(...)](asyncwaitset) |   |   | [c++11](asyncwaitset/c++11) |   |   |   |
| [batching](batching) | **Batching example**: Batching can be used to decrease the amount of communication overhead associated with the transmission and (in the case of reliable communication) acknowledgement of small samples, in order to increase throughput. [(...)](batching) | [c](batching/c) | [c++98](batching/c++98) | [c++11](batching/c++11) |   | [java](batching/java) | [cs](batching/cs) |
| [builtin qos profiles](builtin_qos_profiles) | **Built-in QoS Profiles**: *RTI Connext DDS* provides *Quality of Service* (QoS) that controls the behavior of the different DDS entities, and allows you to configure the *middleware* to enable features such as monitoring. To make this process easier, RTI includes a set of built-in QoS profiles that provide useful functionality, such as enabling monitoring or configuring *DataWriters* and *DataReaders* to be strictly reliable. [(...)](builtin_qos_profiles) | [c](builtin_qos_profiles/c) | [c++98](builtin_qos_profiles/c++98) | [c++11](builtin_qos_profiles/c++11) |   | [java](builtin_qos_profiles/java) | [cs](builtin_qos_profiles/cs) |
| [builtin topics](builtin_topics) | **Built-in Topics**: *Built-in Topics* are a special kind of topics that are used by *RTI Connext DDS* applications to discover each other. These *Topics* are handled automatically by the middleware, but in certain scenarios it is useful to access to them. For instance, these *Topics* allow us to access some relevant information about Connext entities, such as: [(...)](builtin_topics) | [c](builtin_topics/c) | [c++98](builtin_topics/c++98) | [c++11](builtin_topics/c++11) | [py](builtin_topics/py) | [java](builtin_topics/java) | [cs](builtin_topics/cs) |
| [coherent presentation](coherent_presentation) | **Coherent Presentation**: A publishing application can request that a set of data-sample changes be propagated in such a way that they are interpreted at the receivers' side as a cohesive set of modifications. In this case, the receiver will only be able to access the data after all the modifications in the set are available at the subscribing end. [(...)](coherent_presentation) | [c](coherent_presentation/c) | [c++98](coherent_presentation/c++98) | [c++11](coherent_presentation/c++11) |   | [java](coherent_presentation/java) | [cs](coherent_presentation/cs) |
| [compression](compression) | **Data Compression**: The compression feature allows compressing the *USER_DATA* samples sent by a *DataWriter*. Compression can be configured by 3 QoSs (See the ConnextDDS_CoreLibraries user-manual for more information): [(...)](compression) |   | [c++98](compression/c++98) | [c++11](compression/c++11) |   |   |   |
| [content filtered topic](content_filtered_topic) | **Content Filtered Topic**: A *Content Filtered Topic* is a *Topic* with filtering properties. It makes it possible to subscribe to topics and at the same time specify that you are only interested in a subset of the *Topic's* data. For example, suppose you have a *Topic* that contains a temperature reading for a boiler, but you are only interested in temperatures outside the normal operating range. A *Content Filtered Topic* can be used to limit the number of data samples a *DataReader* has to process and may also reduce the amount of data sent over the network. [(...)](content_filtered_topic) | [c](content_filtered_topic/c) | [c++98](content_filtered_topic/c++98) | [c++11](content_filtered_topic/c++11) | [py](content_filtered_topic/py) | [java](content_filtered_topic/java) | [cs](content_filtered_topic/cs) |
| [content filtered topic string filter](content_filtered_topic_string_filter) | **Content Filtered Topic - Using String Filter**: A *Content Filtered Topic* is a *Topic* with filtering properties. It makes it possible to subscribe to topics and at the same time specify that you are only interested in a subset of the *Topic's* data. For example, suppose you have a *Topic* that contains a temperature reading for a boiler, but you are only interested in temperatures outside the normal operating range. A *Content Filtered Topic* can be used to limit the number of data samples a *DataReader* has to process and may also reduce the amount of data sent over the network. [(...)](content_filtered_topic_string_filter) | [c](content_filtered_topic_string_filter/c) | [c++98](content_filtered_topic_string_filter/c++98) | [c++11](content_filtered_topic_string_filter/c++11) | [py](content_filtered_topic_string_filter/py) | [java](content_filtered_topic_string_filter/java) | [cs](content_filtered_topic_string_filter/cs) |
| [custom content filter](custom_content_filter) | **Custom Content Filter**: *Custom Content Filters* are similar to the *Content Filtered Topic* (see example. The main difference is that Custom Content Filters allow the use of non-relational operations between topic members, i.e. a computation involving topic members. Similarly to what happens with the Content Filtered Topics, after applying a custom content filter you will get a subset of all samples that fulfill an expression. [(...)](custom_content_filter) | [c](custom_content_filter/c) | [c++98](custom_content_filter/c++98) | [c++11](custom_content_filter/c++11) |   | [java](custom_content_filter/java) | [cs](custom_content_filter/cs) |
| [custom flow controller](custom_flow_controller) | **Custom Flowcontroller**: A *FlowController* is the object responsible for shaping the network traffic by determining when attached asynchronous *DataWriters* are allowed to write data. [(...)](custom_flow_controller) | [c](custom_flow_controller/c) | [c++98](custom_flow_controller/c++98) | [c++11](custom_flow_controller/c++11) |   | [java](custom_flow_controller/java) | [cs](custom_flow_controller/cs) |
| [custom transport](custom_transport) | **Creating a Custom Transport**: RTI Connext DDS interacts with the underlying network/communications transport via a RTI Pluggable Transport API (PT API). The PT API sits in the protocol stack below the DDS Protocol (DDS-RTPS) layer. It is used for sending and receiving all the information between DomainParticipants. [(...)](custom_transport) | [c](custom_transport/c) |   |   |   |   |   |
| [deadline contentfilter](deadline_contentfilter) | **Deadlines and Content Filtering**: In *RTI Connext DDS*, you can use the `DEADLINE` QoS to specify that you expect updates about a particular instance within a given period of time. [(...)](deadline_contentfilter) | [c](deadline_contentfilter/c) | [c++98](deadline_contentfilter/c++98) | [c++11](deadline_contentfilter/c++11) |   | [java](deadline_contentfilter/java) | [cs](deadline_contentfilter/cs) |
| [detect samples dropped](detect_samples_dropped) | **Detect Samples Dropped by the DataReader**: RTI Connext DDS provides information through statistics about every sample that is not seen by a subscribing application. Dropped samples are exposed through counters in the DataReaderCacheStatus and DataReaderProtocolStatus: [(...)](detect_samples_dropped) | [c](detect_samples_dropped/c) | [c++98](detect_samples_dropped/c++98) | [c++11](detect_samples_dropped/c++11) |   | [java](detect_samples_dropped/java) |   |
| [discovery snapshot](discovery_snapshot) | **Discovery Snapshot**: RTI Connext DDS allows you to take discovery snapshots of DomainParticipants, DataWriters, and DataReaders. Discovery snapshots are useful when your applications are not communicating as expected. [(...)](discovery_snapshot) | [c](discovery_snapshot/c) |   | [c++11](discovery_snapshot/c++11) |   |   |   |
| [dynamic data access union discriminator](dynamic_data_access_union_discriminator) | **Access Union Discriminators in Dynamic Data**: Unions in IDL are mapped to structs in C and C++, so that *Connext* will not have to dynamically allocate memory for unions containing variable-length fields such as strings or sequences. To be efficient, the entire struct (or class in C++/CLI) is not sent when the union is published. Instead, Connext uses the discriminator field of the struct to decide what field in the struct is actually sent on the wire. [(...)](dynamic_data_access_union_discriminator) | [c](dynamic_data_access_union_discriminator/c) | [c++98](dynamic_data_access_union_discriminator/c++98) | [c++11](dynamic_data_access_union_discriminator/c++11) |   | [java](dynamic_data_access_union_discriminator/java) | [cs](dynamic_data_access_union_discriminator/cs) |
| [dynamic data nested structs](dynamic_data_nested_structs) | **Dynamic Data API: access to complex member example**: *Dynamic Data API* allows to create topic samples in a programmatically manner without defining an IDL in compile time. Analogously to the IDL based approach, the *Dynamic Data API* provide methods to get/set complex members in dynamic data samples. [(...)](dynamic_data_nested_structs) | [c](dynamic_data_nested_structs/c) | [c++98](dynamic_data_nested_structs/c++98) | [c++11](dynamic_data_nested_structs/c++11) |   | [java](dynamic_data_nested_structs/java) | [cs](dynamic_data_nested_structs/cs) |
| [dynamic data request reply](dynamic_data_request_reply) | **Request-Reply DynamicData Application**: *Dynamic Data* API allows user to create topic types in a programmatic manner without defining an IDL at compile time. [(...)](dynamic_data_request_reply) |   |   | [c++11](dynamic_data_request_reply/c++11) |   |   |   |
| [dynamic data sequences](dynamic_data_sequences) | **Dynamic Data: Accessing Sequence Members**: *Dynamic Data* provides an easy way to access the members of a data sample. Such members can be primitive data types or complex data types such as arrays or sequences. [(...)](dynamic_data_sequences) | [c](dynamic_data_sequences/c) | [c++98](dynamic_data_sequences/c++98) | [c++11](dynamic_data_sequences/c++11) |   | [java](dynamic_data_sequences/java) | [cs](dynamic_data_sequences/cs) |
| [dynamic data using publisher subscriber](dynamic_data_using_publisher_subscriber) | **Dynamic Data API: publish/subscribe with Dynamic Data**: *Dynamic Data* provides an easy way to access the members of a data sample. Such members can be primitive data types or complex data types such as arrays or sequences. [(...)](dynamic_data_using_publisher_subscriber) | [c](dynamic_data_using_publisher_subscriber/c) | [c++98](dynamic_data_using_publisher_subscriber/c++98) | [c++11](dynamic_data_using_publisher_subscriber/c++11) |   | [java](dynamic_data_using_publisher_subscriber/java) | [cs](dynamic_data_using_publisher_subscriber/cs) |
| [flat data api](flat_data_api) | **Flat Data API**: Connext 6 introduces two features - *Zero Copy Transfer over Shared Memory* and *FlatData Language Binding*. These features enable the middleware to reduce the number of copies involved in sending a sample, resulting in lower latencies. In the case of *Zero Copy Transfer over Shared Memory*, a fixed minimal latency is guaranteed regardless of the size of the sample. [(...)](flat_data_api) |   | [c++98](flat_data_api/c++98) | [c++11](flat_data_api/c++11) |   |   |   |
| [flat data latency](flat_data_latency) | **FlatData and ZeroCopy**: Connext 6 introduces two features - *Zero Copy Transfer over Shared Memory* and *FlatData Language Binding*. These features enable the middleware to reduce the number of copies involved in sending a sample, resulting in lower latencies. In the case of *Zero Copy Transfer over Shared Memory*, a fixed minimal latency is guaranteed regardless of the size of the sample. [(...)](flat_data_latency) |   |   | [c++11](flat_data_latency/c++11) |   |   |   |
| [fragmented data statistics](fragmented_data_statistics) | **Fragmented Data Statistics**: RTI Connext DDS provides information about fragmented data statistics. [(...)](fragmented_data_statistics) | [c](fragmented_data_statistics/c) | [c++98](fragmented_data_statistics/c++98) | [c++11](fragmented_data_statistics/c++11) |   | [java](fragmented_data_statistics/java) |   |
| [get publishers](get_publishers) | **Use the get_publishers() API**: The *get_publishers()* API allow the application to access all the publishers the participant has. [(...)](get_publishers) | [c](get_publishers/c) | [c++98](get_publishers/c++98) | [c++11](get_publishers/c++11) |   | [java](get_publishers/java) | [cs](get_publishers/cs) |
| [group coherent presentation](group_coherent_presentation) | **Group Coherent Presentation**: A publishing application can request that a set of data-sample changes across multiple DataWriters be propagated in such a way that they are interpreted at the receivers' side as a cohesive set of modifications. In this case, the matching DataReaders will only be able to access the data after all the modifications in the set are available at the subscribing end. [(...)](group_coherent_presentation) |   |   | [c++11](group_coherent_presentation/c++11) | [py](group_coherent_presentation/py) |   | [cs](group_coherent_presentation/cs) |
| [high priority first flow controller](high_priority_first_flow_controller) | **High Priority First Flow Controller Example**: A flow controller can be used to shape the output traffic. There are many types of flow controllers, including a high priority one (DDS_HPF_FLOW_CONTROLLER_SCHED_POLICY) that sends out higher priority samples first. Priority can be assigned on a per sample basis, per channel basis (if using multiple channels), or per writer basis. [(...)](high_priority_first_flow_controller) |   | [c++98](high_priority_first_flow_controller/c++98) |   |   |   |   |
| [instance statistics](instance_statistics) | **Instance Statistics**: RTI Connext DDS provides information about the instances that are currently being maintained by a DataReader or DataWriter. [(...)](instance_statistics) | [c](instance_statistics/c) | [c++98](instance_statistics/c++98) | [c++11](instance_statistics/c++11) |   | [java](instance_statistics/java) | [cs](instance_statistics/cs) |
| [keyed data](keyed_data) | **Keyed data**: Topics come in two flavors: those whose associated data type has specified some fields as defining the **key**, and those whose associated data type has not. If the data type has some fields that act as a *key*, the *Topic* essentially defines a collection of data-instances whose values can be independently maintained. [(...)](keyed_data) | [c](keyed_data/c) | [c++98](keyed_data/c++98) | [c++11](keyed_data/c++11) |   | [java](keyed_data/java) | [cs](keyed_data/cs) |
| [keyed data advanced](keyed_data_advanced) | **Keyed Data --   Advanced**: This is a second example that shows some advanced concepts related to keyed data. As this example builds on [*Keyed Data*](https://github.com/rticommunity/rticonnextdds-examples/tree/master/examples/keyed_data) example, it is advisable to understand that example before investigating this one. [(...)](keyed_data_advanced) | [c](keyed_data_advanced/c) | [c++98](keyed_data_advanced/c++98) | [c++11](keyed_data_advanced/c++11) |   | [java](keyed_data_advanced/java) | [cs](keyed_data_advanced/cs) |
| [lambda content filter](lambda_content_filter) | **C++11 lambda content filter**: *Connext DDS* provides built-in content filters, most notably the *SQL filter*. This filter parses ("compiles") a SQL string expression to create a set of steps that, when executed on each data sample, determine if it passes the filter or not. The *SQL filter* main advantage is its ease of use and flexibility: you just need to type a SQL expression. However it is prone to runtime errors—*Connext DDS* detects syntactic or semantic errors in the expression when it parses it—and relatively inefficient. [(...)](lambda_content_filter) |   |   | [c++11](lambda_content_filter/c++11) |   |   |   |
| [lbediscovery xml app creation](lbediscovery_xml_app_creation) | **LBED and XML-Based Application Creation**: The *RTI Limited Bandwidth Endpoint Discovery (LBED) Plugin* reduces discovery time and network traffic by locally defining information about the endpoints that need to be discovered in an XML file. The Simple Endpoint Discovery Protocol (SEDP), the default dynamic endpoint discovery process, on the other hand, sends the information about the endpoints over the network. Therefore, LBED requires all the endpoints to be known ahead of time and each must be declared in an XML file. [(...)](lbediscovery_xml_app_creation) |   |   | [c++11](lbediscovery_xml_app_creation/c++11) |   |   |   |
| [listeners](listeners) | **Listeners**: The *Listener* class is the abstract base class for all listeners. Each entity class (*DomainParticipant*, *Topic*, *Publisher*, *DataWriter*, *Subscriber*, and *DataReader*) has its own derived *Listener* class that add methods for handling entity-specific statuses. The methods are called by an internal *RTI Connext DDS* thread when the corresponding status for the *Entity* changes value. [(...)](listeners) | [c](listeners/c) | [c++98](listeners/c++98) | [c++11](listeners/c++11) |   | [java](listeners/java) | [cs](listeners/cs) |
| [logging config](logging_config) | **Use the Logging API and explanation of NDDS_Config_LogPrintFormat**: -   **NDDS_Config_LogVerbosity**: The verbosities at which RTI Connext diagnostic information is logged. -   **NDDS_Config_LogLevel**: Level category assigned to RTI Connext log messages returned to an output device. -   **NDDS_Config_LogPrintFormat**: The format used to output RTI Connext diagnostic information. -   **NDDS_CONFIG_LOG_PRINT_FORMAT_MAXIMAL**: Print all available fields: timestamp,     thread Name, Activity Context, Module, File and Line, Method, Message Id and     Backtrace. [(...)](logging_config) | [c](logging_config/c) | [c++98](logging_config/c++98) | [c++11](logging_config/c++11) |   | [java](logging_config/java) |   |
| [multichannel](multichannel) | **MultiChannel**: The `MULTI_CHANNEL` Qos policy is used to partition the data published by a *DataWriter* across multiple channels. A channel is defined by a filter expression and a sequence of multicast locators. [(...)](multichannel) | [c](multichannel/c) | [c++98](multichannel/c++98) | [c++11](multichannel/c++11) |   | [java](multichannel/java) | [cs](multichannel/cs) |
| [network capture](network_capture) | **Network Capture**: *Connext DDS* allows you to capture network traffic that one or more *DomainParticipants* send or receive. This feature can be used to analyze and debug communication problems between your DDS applications. When network capture is enabled, each *DomainParticipant* will generate a pcap-based file that can then be opened by a packet analyzer like Wireshark, provided the right dissectors are installed. [(...)](network_capture) |  |
| [ordered presentation](ordered_presentation) | **Ordered presentation**: Usually *DataReaders* will receive data in the order that it was sent by a *DataWriter*. In addition, data is presented to the *DataReader* as soon as the application receives the next value expected. [(...)](ordered_presentation) | [c](ordered_presentation/c) | [c++98](ordered_presentation/c++98) | [c++11](ordered_presentation/c++11) |   | [java](ordered_presentation/java) | [cs](ordered_presentation/cs) |
| [ordered presentation group](ordered_presentation_group) | **Ordered Presentation Group**: Usually *DataReaders* will receive data in the order that it was sent by a *DataWriter*. In addition, data is presented to the *DataReader* as soon as the application receives the next value expected. [(...)](ordered_presentation_group) | [c](ordered_presentation_group/c) | [c++98](ordered_presentation_group/c++98) | [c++11](ordered_presentation_group/c++11) |   | [java](ordered_presentation_group/java) | [cs](ordered_presentation_group/cs) |
| [partitions](partitions) | **Partitions**: The *PARTITION QoS* provides another way to control which *DataWriters* will match, and thus communicate with, which *DataReaders*. It can be used to prevent *DataWriters* and *DataReaders* that would have otherwise matched with the same *Topic* and compatible *QosPolicies* from talking to each other. Much in the same way that only applications within the same domain will communicate with each other, only *DataWriters* and *DataReaders* that belong to the same partition can talk to each other. [(...)](partitions) | [c](partitions/c) | [c++98](partitions/c++98) | [c++11](partitions/c++11) | [py](partitions/py) | [java](partitions/java) | [cs](partitions/cs) |
| [polling querycondition](polling_querycondition) | **Polling With Query Condition**: In *RTI Connext DDS*, you have the option to query for data that is already in the *DataReader's* queue using a *QueryCondition* object. [(...)](polling_querycondition) | [c](polling_querycondition/c) | [c++98](polling_querycondition/c++98) | [c++11](polling_querycondition/c++11) |   | [java](polling_querycondition/java) | [cs](polling_querycondition/cs) |
| [polling read](polling_read) | **Polling Read**: In *RTI Connext DDS* there are three ways to receive data: [(...)](polling_read) | [c](polling_read/c) | [c++98](polling_read/c++98) | [c++11](polling_read/c++11) |   | [java](polling_read/java) | [cs](polling_read/cs) |
| [printing qos](printing_qos) | **Printing QoS**: RTI Connext DDS provides the possibility to print the following QoS objects: `DataReaderQos`, `DataWriterQos`, `PublisherQos`, `SubscriberQos`, `TopicQos`, `DomainParticipantQos` and `DomainParticipantFactoryQos`. [(...)](printing_qos) | [c](printing_qos/c) | [c++98](printing_qos/c++98) | [c++11](printing_qos/c++11) |   | [java](printing_qos/java) | [cs](printing_qos/cs) |
| [property qos](property_qos) | **Using the Property QoS**: The Property QosPolicy is used to specify name/value pairs of data and attach them to an entity, such as a DomainParticipant. [(...)](property_qos) | [c](property_qos/c) | [c++98](property_qos/c++98) |   |   | [java](property_qos/java) | [cs](property_qos/cs) |
| [real time wan transport](real_time_wan_transport) | **Real-Time WAN Transport**: Real-Time WAN Transport is a smart transport that enables secure, scalable, and high-performance communication over wide area networks (WANs), including public networks. It extends Connext DDS capabilities to WAN environments. Real-Time WAN Transport uses UDP as the underlying IP transport-layer protocol to better anticipate and adapt to the challenges of diverse network conditions, device mobility, and the dynamic nature of WAN system architectures. [(...)](real_time_wan_transport) |   | [c++98](real_time_wan_transport/c++98) |   |   |   |   |
| [remote procedure call](remote_procedure_call) | **Remote Procedure Call**: Remote Procedure Call (RPC) is a specialization of the Request-Reply communication pattern. It simplifies "client" and "service" applications by using a service interface with operations that are implemented in the service and called from the clients. [(...)](remote_procedure_call) |   |   | [c++11](remote_procedure_call/c++11) | [py](remote_procedure_call/py) |   |   |
| [request reply](request_reply) | **Request-Reply**: Request-reply is a communication pattern offered in addition to publish-subscribe.  Sometimes an application needs to get a one-time snapshot of information; for example, to make a query into a database or retrieve configuration parameters that never change. Other times an application needs to ask a remote application to perform an action on its behalf; for example, to invoke a remote procedure call or a service. [(...)](request_reply) |   |   |   | [py](request_reply/py) |   | [cs](request_reply/cs) |
| [required subscription](required_subscription) | **Required Subscription**: There are scenarios where you know a priori that a particular set of applications will join the system: e.g., a logging service or a known processing application. [(...)](required_subscription) |   | [c++98](required_subscription/c++98) |   |   |   |   |
| [time based filter](time_based_filter) | **Time Based Filters**: The `TIME_BASED_FILTER` QoS Policy allows you to specify that data should not be delivered more than once per specified period for data-instances of a *DataReader*, regardless of how fast *DataWriters* are publishing new samples of the data-instance. [(...)](time_based_filter) | [c](time_based_filter/c) | [c++98](time_based_filter/c++98) | [c++11](time_based_filter/c++11) |   | [java](time_based_filter/java) | [cs](time_based_filter/cs) |
| [using qos profiles](using_qos_profiles) | **Using QoS Profiles**: A QoS profile is a collection of QoS settings, usually one per entity, specified in XML format. For example: [(...)](using_qos_profiles) | [c](using_qos_profiles/c) | [c++98](using_qos_profiles/c++98) | [c++11](using_qos_profiles/c++11) | [py](using_qos_profiles/py) | [java](using_qos_profiles/java) | [cs](using_qos_profiles/cs) |
| [using sequences](using_sequences) | **Using Sequences**: A *sequence* is an ordered collection of elements of the same type. The type of a sequence containing elements of type *Foo* (whether *Foo* is one of your types or a built-in Connext type) is typically called *FooSeq*. [(...)](using_sequences) | [c](using_sequences/c) | [c++98](using_sequences/c++98) |   |   | [java](using_sequences/java) | [cs](using_sequences/cs) |
| [using typecodes](using_typecodes) | **Using TypeCodes**: *Type schemas* -- the names and definitions of a type and its fields -- are represented by *TypeCode* objects. A type code value consists of a type code kind and a list of members. Type codes unambiguously match type representations and provide a more reliable test than comparing the string type names. [(...)](using_typecodes) | [c](using_typecodes/c) | [c++98](using_typecodes/c++98) | [c++11](using_typecodes/c++11) |   | [java](using_typecodes/java) | [cs](using_typecodes/cs) |
| [waitset query cond](waitset_query_cond) | **WaitSets using Query Conditions**: *Conditions* and *WaitSets* provide another way for *Connext* to communicate status changes (including the arrival of data) to your application. While a *Listener* is used to provide a callback for asynchronous access, *Conditions* and *WaitSets* provide synchronous data access. In other words, *Listeners* are *notification-based* and *Conditions* are *wait-based*. [(...)](waitset_query_cond) | [c](waitset_query_cond/c) | [c++98](waitset_query_cond/c++98) | [c++11](waitset_query_cond/c++11) | [py](waitset_query_cond/py) | [java](waitset_query_cond/java) | [cs](waitset_query_cond/cs) |
| [waitset status cond](waitset_status_cond) | **WaitSet with Status Condition**: *Conditions* and *WaitSets* provide another way for *Connext* to communicate status changes (including the arrival of data) to your application. While a *Listener* is used to provide a callback for asynchronous access, *Conditions* and *WaitSets* provide synchronous data access. In other words, *Listeners* are *notification-based* and *Conditions* are *wait-based*. [(...)](waitset_status_cond) | [c](waitset_status_cond/c) | [c++98](waitset_status_cond/c++98) | [c++11](waitset_status_cond/c++11) |   | [java](waitset_status_cond/java) | [cs](waitset_status_cond/cs) |
| [waitsets](waitsets) | **WaitSets**: *Conditions* and *WaitSets* provide another way for *Connext* to communicate status changes (including the arrival of data) to your application. While a *Listener* is used to provide a callback for asynchronous access, *Conditions* and *WaitSets* provide synchronous data access. In other words, *Listeners* are *notification-based* and *Conditions* are *wait-based*. [(...)](waitsets) | [c](waitsets/c) | [c++98](waitsets/c++98) | [c++11](waitsets/c++11) |   | [java](waitsets/java) | [cs](waitsets/cs) |
| [xml application env](xml_application_env) | **XML Application Creation - Environment**: The purpose of this example is to demonstrate the use of XML Application Creation and the DynamicData API.  The use case is to have an application publish environment variables for itself as well as receive environment variables from other instances.  These are published to the XML defined EnvironmentTopic. [(...)](xml_application_env) |   |   | [c++11](xml_application_env/c++11) |   |   |   |

